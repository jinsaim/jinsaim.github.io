<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>천자문 연습</title>
	<style>
		:root {
			--bg: #0f172a; /* slate-900 */
			--panel: #111827; /* gray-900 */
			--muted: #94a3b8; /* slate-400 */
			--text: #e5e7eb; /* gray-200 */
			--accent: #22c55e; /* green-500 */
			--accent-2: #60a5fa; /* blue-400 */
			--danger: #f43f5e; /* rose-500 */
			--warn: #f59e0b; /* amber-500 */
		}
		* { box-sizing: border-box; }
		body { margin: 0; background: linear-gradient(120deg, #0b1020, #111a2f); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, sans-serif; }
		header { padding: 1rem 1.25rem; border-bottom: 1px solid #1f2937; position: sticky; top: 0; background: rgba(17,24,39,0.8); backdrop-filter: blur(6px); }
		header h1 { margin: 0; font-size: 1.125rem; }
		.container { max-width: 980px; margin: 0 auto; padding: 1rem 1.25rem; }
		.toolbar { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; }
		.toolbar select, .toolbar button, .toolbar input[type="text"] { background: #0b1220; color: var(--text); border: 1px solid #1f2937; padding: .5rem .75rem; border-radius: .5rem; }
		.toolbar button { cursor: pointer; }
		.toolbar button.primary { background: var(--accent); color: #052e13; border-color: transparent; font-weight: 600; }
		.toolbar label.lbl { color: var(--muted); font-size: .9rem; margin-left: .25rem; }
		.grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(72px, 1fr)); gap: .75rem; margin-top: 1rem; }
		/* Force 8 characters per row in learn view (with small-screen fallbacks) */
		#learnGrid { grid-template-columns: repeat(8, 1fr); }
		@media (max-width: 640px) { #learnGrid { grid-template-columns: repeat(4, 1fr); } }
		@media (max-width: 400px) { #learnGrid { grid-template-columns: repeat(2, 1fr); } }
		.card { background: #0b1220; border: 1px solid #1f2937; border-radius: .75rem; padding: .75rem; text-align: center; transition: transform .12s ease, border-color .12s ease; }
		.card:hover { transform: translateY(-2px); border-color: #334155; }
		.hanja { font-size: 28px; line-height: 1.2; }
		.hangeul { font-size: 12px; color: var(--muted); margin-top: .25rem; }
		.meta { margin-top: .35rem; font-size: 11px; color: #a1a1aa; }
		.mode { display: none; }
		.mode.active { display: block; }
		.panel { background: #0b1220; border: 1px solid #1f2937; border-radius: .75rem; padding: 1rem; margin-top: 1rem; }
		.row { display: grid; grid-template-columns: 1fr 1fr; gap: .75rem; align-items: center; }
		.row input, .row textarea { width: 100%; background: #0b1020; border: 1px solid #1f2937; color: var(--text); border-radius: .5rem; padding: .6rem .7rem; }
		.row label { font-size: .9rem; color: var(--muted); }
		.quiz { text-align: center; }
		.quiz .question { font-size: 36px; margin: .75rem 0; }
		.quiz .hint { color: var(--muted); font-size: .95rem; }
		.quiz input { margin-top: .5rem; font-size: 1rem; }
		.quiz .result { margin-top: .75rem; font-weight: 600; }
		.ok { color: var(--accent); }
		.bad { color: var(--danger); }
		.footer { color: var(--muted); font-size: .85rem; margin-top: 1rem; text-align: right; }

		/* Stroke-order modal */
		.modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 50; }
		.modal.show { display: flex; }
		.modal-content { width: min(92vw, 420px); background: #0b1220; border: 1px solid #1f2937; border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
		.modal-header { display: flex; align-items: center; justify-content: space-between; padding: .9rem 1rem; border-bottom: 1px solid #1f2937; }
		.modal-title { font-weight: 700; }
		.modal-body { padding: 1rem; display: grid; gap: .5rem; justify-items: center; }
		#strokeTarget { width: 280px; height: 280px; background: #0b1020; border: 1px dashed #334155; border-radius: .75rem; display: grid; place-items: center; }
		.modal-footer { padding: .9rem 1rem; display: flex; gap: .5rem; justify-content: flex-end; border-top: 1px solid #1f2937; }
		.btn { background: #0b1220; color: var(--text); border: 1px solid #334155; padding: .5rem .8rem; border-radius: .5rem; cursor: pointer; }
		.btn:hover { border-color: #475569; }
		.btn.primary { background: var(--accent); color: #052e13; border-color: transparent; font-weight: 700; }

		/* Bulk import modal */
		#bulkText { width: 100%; min-height: 180px; background: #0b1020; color: var(--text); border: 1px solid #1f2937; border-radius: .5rem; padding: .75rem; }
	</style>
    <script src="https://cdn.jsdelivr.net/npm/hanzi-writer@2.2/dist/hanzi-writer.min.js"></script>
</head>
<body>
	<header>
		<h1>천자문 연습 · 1000字</h1>
	</header>
	<div class="container">
		<div class="toolbar">
			<select id="modeSelect" title="모드 선택">
				<option value="learn">학습</option>
				<option value="quiz">퀴즈</option>
				<option value="write">쓰기</option>
			</select>
			<input type="text" id="search" placeholder="검색(한자/음/뜻)" />
			<label for="groupFilter" class="lbl">묶음:</label>
			<select id="groupFilter" title="묶음 선택">
				<option value="">전체 묶음</option>
			</select>
			<button id="shuffleBtn">섞기</button>
			<button id="resetBtn">초기화</button>
			<button id="exportBtn">백업</button>
			<input id="importFile" type="file" accept="application/json" style="display:none" />
			<button id="importBtn">가져오기</button>
			<button id="bulkBtn" class="primary" title="천자문 전체를 빠르게 붙여넣기로 등록">전체 붙여넣기</button>
			<span class="footer" id="countInfo"></span>
		</div>

		<!-- 학습 모드 -->
		<section id="mode-learn" class="mode active">
			<div class="grid" id="learnGrid"></div>
		</section>

		<!-- 퀴즈 모드 -->
		<section id="mode-quiz" class="mode">
			<div class="panel quiz">
				<div class="hint">한자를 보고 음(훈)을 쓰세요</div>
				<div class="question" id="quizQuestion">天</div>
				<input id="quizAnswer" type="text" placeholder="정답 입력" />
				<div>
					<button id="quizCheck" class="primary">정답 확인</button>
					<button id="quizNext">다음</button>
				</div>
				<div class="result" id="quizResult"></div>
			</div>
		</section>

		<!-- 쓰기 모드 -->
		<section id="mode-write" class="mode">
			<div class="panel">
				<div class="row">
					<label>한자</label>
					<input id="wChar" maxlength="1" placeholder="例) 天" />
				</div>
				<div class="row">
					<label>음/훈</label>
					<input id="wRead" placeholder="例) 천/하늘" />
				</div>
				<div class="row">
					<label>뜻/설명</label>
					<textarea id="wMean" rows="2" placeholder="간단한 설명"></textarea>
				</div>
				<div class="row">
					<label>묶음(행/절)</label>
					<input id="wGroup" placeholder="例) 001 (1~4자)" />
				</div>
				<div style="margin-top:.5rem">
					<button id="wAdd" class="primary">추가</button>
				</div>
			</div>
		</section>

	</div>

		<!-- Stroke-order Modal -->
		<div id="strokeModal" class="modal" aria-hidden="true">
			<div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="strokeTitle">
				<div class="modal-header">
					<div class="modal-title" id="strokeTitle">필순 보기</div>
					<button id="strokeClose" class="btn" aria-label="닫기">닫기</button>
				</div>
				<div class="modal-body">
					<div id="strokeTarget"></div>
					<div id="strokeMeta" style="color: var(--muted); font-size: .9rem;"></div>
				</div>
				<div class="modal-footer">
					<button id="strokeReplay" class="btn primary">다시 보기</button>
				</div>
			</div>
		</div>

			<!-- Bulk Paste Modal -->
			<div id="bulkModal" class="modal" aria-hidden="true">
				<div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="bulkTitle">
					<div class="modal-header">
						<div class="modal-title" id="bulkTitle">천자문 전체 붙여넣기</div>
						<button id="bulkClose" class="btn" aria-label="닫기">닫기</button>
					</div>
					<div class="modal-body" style="width:min(92vw, 620px)">
						<div style="font-size:.9rem; color:var(--muted); line-height:1.6; text-align:left;">
							천자문 1000자를 복사해 아래 상자에 붙여넣으세요. 공백/줄바꿈은 제거되며, 4자씩 한 묶음(001부터)으로 자동 그룹화됩니다.
						</div>
						<textarea id="bulkText" placeholder="예) 天地玄黃宇宙洪荒...  (1000자)"></textarea>
					</div>
					<div class="modal-footer">
						<button id="bulkReplace" class="btn" title="기존 데이터를 전체 교체">전체 교체</button>
						<button id="bulkMerge" class="btn primary" title="기존 데이터에 추가(중복 제거)">추가(중복 제거)</button>
					</div>
				</div>
			</div>

	<script>
		// 기본 데이터(시드). 이후 JSON으로 전체를 불러올 수 있음
		const seed = [
			{ ch: '天', read: '천', mean: '하늘', group: '001' },
			{ ch: '地', read: '지', mean: '땅', group: '001' },
			{ ch: '玄', read: '현', mean: '검다, 오묘하다', group: '001' },
			{ ch: '黃', read: '황', mean: '누르다', group: '001' },
			{ ch: '宇', read: '우', mean: '집, 공간', group: '002' },
			{ ch: '宙', read: '주', mean: '시간, 시공', group: '002' },
			{ ch: '洪', read: '홍', mean: '크다', group: '002' },
			{ ch: '荒', read: '황', mean: '거칠다', group: '002' },
		];

		const LS_KEY = 'thousandChars_v1';
		let data = [];

		function loadData() {
			try {
				const raw = localStorage.getItem(LS_KEY);
				data = raw ? JSON.parse(raw) : seed;
			} catch (e) {
				console.warn('localStorage 읽기 실패, seed 사용', e);
				data = seed;
			}
		}

		function saveData() { try { localStorage.setItem(LS_KEY, JSON.stringify(data)); } catch (e) { console.warn('저장 실패', e); } }

		function setMode(mode) {
			document.querySelectorAll('.mode').forEach(el => el.classList.remove('active'));
			document.getElementById('mode-' + mode).classList.add('active');
		}

		function renderLearn(list) {
			const el = document.getElementById('learnGrid');
			el.innerHTML = (list || data).map((x, i) => `
				<div class="card" data-idx="${i}">
					<div class="hanja">${x.ch}</div>
					<div class="hangeul">${x.read}</div>
					<div class="meta">${x.mean || ''}</div>
				</div>
			`).join('');
			document.getElementById('countInfo').textContent = `${(list || data).length}자`;
		}

		function shuffle(arr) {
			const a = [...arr];
			for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; }
			return a;
		}

		// 검색 + 그룹 필터
		function doSearch() {
			const q = document.getElementById('search').value.trim();
			const grp = document.getElementById('groupFilter').value;
			let list = data;
			if (grp) list = list.filter(x => (x.group || '') === grp);
			if (q) {
				const re = new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
				list = list.filter(x => re.test(x.ch) || re.test(x.read) || re.test(x.mean || ''));
			}
			renderLearn(list);
		}

		function rebuildGroupFilter() {
			const sel = document.getElementById('groupFilter');
			const current = sel.value;
			const groups = Array.from(new Set(data.map(x => x.group).filter(Boolean))).sort();
			sel.innerHTML = '<option value="">전체 묶음</option>' + groups.map(g => `<option value="${g}">${g}</option>`).join('');
			if (current && groups.includes(current)) sel.value = current;
		}

		// 퀴즈
		let quizIndex = 0;
		let quizList = [];
		function startQuiz() { quizList = shuffle(data); quizIndex = 0; showQuiz(); }
		function showQuiz() {
			if (!quizList.length) { startQuiz(); return; }
			const q = quizList[quizIndex % quizList.length];
			document.getElementById('quizQuestion').textContent = q.ch;
			document.getElementById('quizAnswer').value = '';
			document.getElementById('quizResult').textContent = '';
		}
		function checkQuiz() {
			const q = quizList[quizIndex % quizList.length];
			const a = document.getElementById('quizAnswer').value.trim();
			const ok = a && (a === q.read || (q.mean && a === q.mean));
			const r = document.getElementById('quizResult');
			r.textContent = ok ? `정답! (${q.read}${q.mean ? ' / ' + q.mean : ''})` : `오답: ${q.read}${q.mean ? ' / ' + q.mean : ''}`;
			r.className = 'result ' + (ok ? 'ok' : 'bad');
		}

		// 쓰기(추가)
		function addItem() {
			const ch = document.getElementById('wChar').value.trim();
			const read = document.getElementById('wRead').value.trim();
			const mean = document.getElementById('wMean').value.trim();
			const group = document.getElementById('wGroup').value.trim() || 'custom';
			if (!ch || !read) { alert('한자와 음/훈을 입력해주세요.'); return; }
			data.push({ ch, read, mean, group });
			saveData();
			renderLearn();
			alert('추가되었습니다.');
			document.getElementById('wChar').value = '';
			document.getElementById('wRead').value = '';
			document.getElementById('wMean').value = '';
			document.getElementById('wGroup').value = '';
		}

		// 백업/가져오기
		function doExport() {
			const blob = new Blob([JSON.stringify({ items: data, exportedAt: new Date().toISOString() }, null, 2)], { type: 'application/json;charset=utf-8' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url; a.download = '1000ja-backup.json'; a.click();
			setTimeout(() => URL.revokeObjectURL(url), 500);
		}
		function doImport(file) {
			const reader = new FileReader();
			reader.onload = () => {
				try {
					const json = JSON.parse(reader.result);
					const items = json.items || json.data || json || [];
					if (!Array.isArray(items)) throw new Error('잘못된 형식');
					// 기본 키 정규화
					data = items.map(x => ({ ch: x.ch || x.char || x.hanja, read: x.read || x.kor || x.ko || '', mean: x.mean || x.desc || '', group: x.group || x.grp || 'import' })).filter(x => x.ch && x.read);
					saveData();
					renderLearn();
					alert(`불러오기 완료: ${data.length}자`);
				} catch (e) {
					alert('가져오기 실패: ' + e.message);
				}
			};
			reader.readAsText(file, 'utf-8');
		}

		// 초기화
		function doReset() { if (confirm('저장된 학습 데이터를 초기화할까요?')) { localStorage.removeItem(LS_KEY); loadData(); renderLearn(); startQuiz(); } }

		// 이벤트 바인딩
		document.addEventListener('DOMContentLoaded', () => {
			loadData();
			renderLearn();
			rebuildGroupFilter();
			startQuiz();

			document.getElementById('modeSelect').addEventListener('change', (e) => setMode(e.target.value));
			document.getElementById('search').addEventListener('input', doSearch);
			document.getElementById('groupFilter').addEventListener('change', doSearch);
			document.getElementById('shuffleBtn').addEventListener('click', () => { data = shuffle(data); saveData(); renderLearn(); startQuiz(); });
			document.getElementById('resetBtn').addEventListener('click', doReset);
			document.getElementById('exportBtn').addEventListener('click', doExport);
			document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFile').click());
			document.getElementById('importFile').addEventListener('change', (e) => { if (e.target.files[0]) { doImport(e.target.files[0]); setTimeout(() => { rebuildGroupFilter(); doSearch(); }, 100); } });

			// Bulk paste modal events
			const bulkModal = document.getElementById('bulkModal');
			document.getElementById('bulkBtn').addEventListener('click', () => { bulkModal.classList.add('show'); });
			document.getElementById('bulkClose').addEventListener('click', () => { bulkModal.classList.remove('show'); });
			bulkModal.addEventListener('click', (e) => { if (e.target === bulkModal) bulkModal.classList.remove('show'); });
			document.getElementById('bulkReplace').addEventListener('click', () => handleBulk('replace'));
			document.getElementById('bulkMerge').addEventListener('click', () => handleBulk('merge'));

			document.getElementById('quizCheck').addEventListener('click', checkQuiz);
			document.getElementById('quizNext').addEventListener('click', () => { quizIndex++; showQuiz(); });
			document.getElementById('quizAnswer').addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); checkQuiz(); } });

			document.getElementById('wAdd').addEventListener('click', () => { addItem(); rebuildGroupFilter(); doSearch(); });

			// 학습 카드 클릭 -> 필순 모달
			const learnGrid = document.getElementById('learnGrid');
			const strokeModal = document.getElementById('strokeModal');
			const strokeTarget = document.getElementById('strokeTarget');
			const strokeTitle = document.getElementById('strokeTitle');
			const strokeMeta = document.getElementById('strokeMeta');
			const strokeClose = document.getElementById('strokeClose');
			const strokeReplay = document.getElementById('strokeReplay');
			let writer = null;

			function openStroke(ch, read, mean){
				// 모달 표시
				strokeTitle.textContent = `필순: ${ch}`;
				strokeMeta.textContent = [read||'', mean||''].filter(Boolean).join(' · ');
				strokeTarget.innerHTML = '';
				strokeModal.classList.add('show');
				// Hanzi Writer 생성
				try {
					writer = HanziWriter.create(strokeTarget, ch, {
						width: 280,
						height: 280,
						padding: 12,
						showCharacter: false,
						strokeColor: '#22c55e',
						radicalColor: '#60a5fa',
						strokeAnimationSpeed: 1.2,
						delayBetweenStrokes: 150,
					});
					writer.animateCharacter();
				} catch (e) {
					strokeTarget.innerHTML = '<div style="padding:1rem; color:#f87171;">이 글자의 필순 데이터를 찾지 못했습니다.</div>';
				}
			}

			function doImport(file) {
				const reader = new FileReader();
				reader.onload = () => {
					try {
						const json = JSON.parse(reader.result);
						let items = [];
						if (Array.isArray(json)) {
							items = json;
						} else if (json && typeof json === 'object') {
							items = json.items || json.data || json.thousandChars_v1 || json.list || null;
							if (!Array.isArray(items)) {
								// root 객체의 첫 번째 Array 값을 자동 탐지
								const firstArray = Object.values(json).find(v => Array.isArray(v));
								if (Array.isArray(firstArray)) items = firstArray;
								// 문자열 페이로드(text/thousandCharsText 등) 자동 처리
								if (!Array.isArray(items)) {
									const textLike = json.text || json.thousandCharsText || json.content || null;
									if (typeof textLike === 'string' && textLike.trim().length >= 4) {
										const cleaned = textLike.replace(/\s+/g, '');
										const onlyHan = Array.from(cleaned).filter(ch => /\p{Script=Han}/u.test(ch));
										if (onlyHan.length >= 4) {
											items = onlyHan.map((ch, i) => ({ ch, read: '', mean: '', group: String(Math.floor(i/4)+1).padStart(3,'0') }));
										}
									}
								}
							}
						}
						if (!Array.isArray(items)) throw new Error('지원되는 JSON 형식이 아닙니다. 배열(items/data/thousandChars_v1/list), 루트 배열, 또는 텍스트(text/thousandCharsText)로 1000자를 제공하세요.');

						// 기본 키 정규화 (read 없어도 유지)
						let incoming = items.map(x => ({ ch: x.ch || x.char || x.hanja, read: x.read || x.kor || x.ko || '', mean: x.mean || x.desc || '', group: x.group || x.grp || 'import' })).filter(x => x.ch);

						// merge 옵션: true면 기존 data에 추가(문자 기준 중복 제거), false면 교체
						const wantMerge = !!(json && json.merge);
						let base = wantMerge ? [...data] : [];
						if (wantMerge) {
							const exist = new Set(base.map(x => x.ch));
							for (const it of incoming) { if (!exist.has(it.ch)) { base.push(it); exist.add(it.ch); } }
						} else {
							base = incoming;
						}

						// dict/map 병합 (문자 기준으로 read/mean/group 덮어쓰기)
						const applyDict = (dictObj) => {
							if (!dictObj || typeof dictObj !== 'object') return;
							const dict = dictObj.dict || dictObj.map || dictObj.dictionary || null;
							if (!dict || typeof dict !== 'object') return;
							const byChar = new Map(base.map(x => [x.ch, x]));
							for (const [ch, v] of Object.entries(dict)) {
								if (!ch || typeof v !== 'object') continue;
								const t = byChar.get(ch) || { ch, read: '', mean: '', group: 'import' };
								if (v.read) t.read = v.read;
								if (v.kor || v.ko) t.read = v.kor || v.ko;
								if (v.mean) t.mean = v.mean;
								if (v.desc) t.mean = v.desc;
								if (v.group || v.grp) t.group = v.group || v.grp;
								byChar.set(ch, t);
							}
							base = Array.from(byChar.values());
						};

						applyDict(json);

						data = base;
						saveData();
						rebuildGroupFilter();
						doSearch();
						alert(`불러오기 완료${wantMerge ? ' (병합)' : ''}: ${data.length}자`);
					} catch (e) {
						alert('가져오기 실패: ' + e.message);
					}
				};
				reader.readAsText(file, 'utf-8');
			}
		}
	</script>
</body>
</html>

